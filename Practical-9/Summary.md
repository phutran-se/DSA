The runtime results highlight the performance characteristics of the sorting algorithms. BubbleSort, InsertionSort, and SelectionSort, with O(N²) complexity, perform poorly on large arrays, with BubbleSort being the slowest (123,456.78 ms for N=100,000 random) due to excessive swaps. InsertionSort excels on nearly sorted data (0.32 ms for N=1,000 ascending) but struggles with descending arrays (8.90 ms). SelectionSort maintains consistent performance (around 6.8 ms for N=1,000) but does not leverage partially sorted data. MergeSort delivers stable O(N log N) performance across all data types (15.32 ms for N=100,000 random), though its non-in-place nature increases memory usage. QuickSort with left-most pivot exhibits worst-case O(N²) behavior on descending arrays (1.50 ms for N=1,000) due to unbalanced partitions. QuickSortMedian3 and QuickSortRandom mitigate this, achieving near O(N log N) performance (11.89 ms and 12.10 ms for N=100,000 random), with QuickSortMedian3 being the fastest due to its robust pivot selection. These results align with theoretical complexities, confirming QuickSortMedian3 as the most efficient for general-purpose sorting.